<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Save Index</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">

    <style>
        :root {
            --hue1: 210; /* Blue */
            --hue2: 280; /* Purple */
            --bg-dark: #0a0e17;
            --text-primary: #f0f8ff;
            --glass-bg: rgba(25, 40, 65, 0.4);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Roboto', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }

        .main-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            z-index: 10;
        }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: rgba(10, 14, 23, 0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid hsl(var(--hue1) 80% 50% / 0.3);
            z-index: 20;
        }

        .top-bar h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: #fff;
            text-shadow: 0 0 10px hsl(var(--hue1) 80% 50%);
        }

        .controls-group { display: flex; align-items: center; gap: 1rem; }

        .control-button, #settings-toggle {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        .control-button:hover, #settings-toggle:hover { background: rgba(255, 255, 255, 0.2); }

        #settings-panel {
            position: fixed;
            top: 0;
            right: -300px; /* Start off-screen */
            width: 280px;
            height: 100%;
            background: linear-gradient(235deg, hsl(var(--hue1) 50% 10% / 0.8), hsl(var(--hue1) 50% 10% / 0) 50%), linear-gradient(hsl(220deg 25% 4.8% / 0.7));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-left: 1px solid hsl(var(--hue2), 12%, 30%);
            z-index: 30;
            padding: 2rem;
            transition: right 0.4s ease-in-out;
        }
        #settings-panel.open { right: 0; }
        
        #settings-panel h2 { margin-bottom: 1.5rem; font-family: 'Orbitron', sans-serif; }
        .theme-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 1.5rem; }
        .theme-button { width: 40px; height: 40px; border-radius: 8px; border: 2px solid rgba(255, 255, 255, .3); cursor: pointer; transition: all .2s; }
        .theme-button.active { border-color: #fff; box-shadow: 0 0 10px #fff; }
        #theme-1 { background: linear-gradient(45deg, #4F46E5, #C026D3); }
        #theme-2 { background: linear-gradient(45deg, #F59E0B, #DC2626); }
        #theme-3 { background: linear-gradient(45deg, #EC4899, #3B82F6); }
        #theme-4 { background: linear-gradient(45deg, #10B981, #FACC15); }
        .density-label { display: flex; justify-content: space-between; margin-bottom: 0.5rem; }
        .density-slider { width: 100%; }

        #save-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 2rem;
            max-width: 1600px;
            margin: 0 auto;
            padding-top: 100px; /* Space for fixed header */
        }

        .save-card {
            background: linear-gradient(hsl(220deg 25% 4.8% / 0.5), hsl(220deg 25% 4.8% / 0.8));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid hsl(var(--hue2), 12%, 30%);
            border-radius: 22px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            color: #f0f8ff;
        }
        .save-card:hover { transform: translateY(-5px); box-shadow: 0 10px 20px rgba(0,0,0,0.4); }
        .save-card h2 { font-family: 'Orbitron', sans-serif; color: #fff; font-size: 1.4rem; }
        .save-card p { color: #b0c4de; font-size: 0.9rem; }
        .download-button { margin-top: auto; padding: 0.8rem 1.2rem; background: hsl(var(--hue1) 30% 15% / 0.5); border: 1px solid hsl(var(--hue1) 15% 16% / 0.5); color: #fff; text-decoration: none; text-align: center; border-radius: 8px; font-weight: 600; transition: all 0.2s ease; }
        .download-button:hover { background: hsl(var(--hue1) 40% 24% / 0.8); box-shadow: 0 0 15px hsl(var(--hue1) 80% 50% / 0.5); }

        .loader, .error-message { grid-column: 1 / -1; text-align: center; padding: 3rem; font-size: 1.2rem; color: #b0c4de; background: rgba(10, 14, 23, 0.5); backdrop-filter: blur(5px); border-radius: 22px; }

        @media (max-width: 768px) {
            .top-bar { padding: 1rem; }
            .top-bar h1 { font-size: 1.2rem; }
            .control-button span { display: none; } /* Hide text on mobile */
            .control-button, #settings-toggle { padding: 0.5rem; }
            #save-container { padding-top: 80px; }
        }
    </style>
</head>
<body>
    <canvas id="neural-network-canvas"></canvas>

    <header class="top-bar">
        <h1>Game Save Index</h1>
        <div class="controls-group">
            <button id="change-formation-btn" class="control-button"><span>Formation</span></button>
            <button id="pause-play-btn" class="control-button"><span>Pause</span></button>
            <button id="reset-camera-btn" class="control-button"><span>Reset Cam</span></button>
            <button id="settings-toggle">⚙️</button>
        </div>
    </header>

    <aside id="settings-panel">
        <h2>Settings</h2>
        <div id="theme-selector">
            <div class="theme-grid">
                <button class="theme-button" id="theme-1" data-theme="0"></button>
                <button class="theme-button" id="theme-2" data-theme="1"></button>
                <button class="theme-button" id="theme-3" data-theme="2"></button>
                <button class="theme-button" id="theme-4" data-theme="3"></button>
            </div>
        </div>
        <div id="density-controls">
            <div class="density-label"><span>Density</span><span id="density-value">100%</span></div>
            <input type="range" min="20" max="100" value="100" class="density-slider" id="density-slider">
        </div>
    </aside>

    <div class="main-content">
        <main>
            <div id="save-container">
                <div class="loader">Loading Save Files...</div>
            </div>
        </main>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilmPass } from 'three/addons/postprocessing/FilmPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        const config = {
            paused: false,
            activePaletteIndex: 1,
            currentFormation: 0,
            numFormations: 4,
            densityFactor: 1
        };

        const colorPalettes = [
            [new THREE.Color(0x4F46E5), new THREE.Color(0x7C3AED), new THREE.Color(0xC026D3), new THREE.Color(0xDB2777), new THREE.Color(0x8B5CF6)],
            [new THREE.Color(0xF59E0B), new THREE.Color(0xF97316), new THREE.Color(0xDC2626), new THREE.Color(0x7F1D1D), new THREE.Color(0xFBBF24)],
            [new THREE.Color(0xEC4899), new THREE.Color(0x8B5CF6), new THREE.Color(0x6366F1), new THREE.Color(0x3B82F6), new THREE.Color(0xA855F7)],
            [new THREE.Color(0x10B981), new THREE.Color(0xA3E635), new THREE.Color(0xFACC15), new THREE.Color(0xFB923C), new THREE.Color(0x4ADE80)]
        ];

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.0015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1200);
        camera.position.set(0, 5, 22);

        const canvasElement = document.getElementById('neural-network-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setClearColor(0x000000);
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        
        const starField = createStarfield();
        scene.add(starField);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.5;
        controls.minDistance = 5;
        controls.maxDistance = 100;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.15;
        controls.enablePan = false;

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.68);
        composer.addPass(bloomPass);
        const filmPass = new FilmPass(0.35, 0.55, 2048, false);
        composer.addPass(filmPass);
        composer.addPass(new OutputPass());

        const pulseUniforms = { uTime: { value: 0.0 }, uPulsePositions: { value: [new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3), new THREE.Vector3(1e3, 1e3, 1e3)] }, uPulseTimes: { value: [-1e3, -1e3, -1e3] }, uPulseColors: { value: [new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1), new THREE.Color(1, 1, 1)] }, uPulseSpeed: { value: 15.0 }, uBaseNodeSize: { value: 0.5 }, uActivePalette: { value: 0 } };
        const noiseFunctions = `
        vec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}
        vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}
        vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}
        float snoise(vec3 v){
            const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);
            vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);
            vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);
            vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);
            vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));
            float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;
            vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);
            vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);
            vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;
            vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;
            vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);
            vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));
            p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);
            m*=m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));
        }
        float fbm(vec3 p,float time){
            float value=0.0;float amplitude=0.5;float frequency=1.0;int octaves=3;
            for(int i=0;i<octaves;i++){
                value+=amplitude*snoise(p*frequency+time*0.2*frequency);
                amplitude*=0.5;frequency*=2.0;
            }
            return value;
        }`;
        const nodeShader = { vertexShader: `${noiseFunctions}\nattribute float nodeSize;attribute float nodeType;attribute vec3 nodeColor;attribute vec3 connectionIndices;attribute float distanceFromRoot;uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;uniform float uBaseNodeSize;varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {if (pulseTime < 0.0) return 0.0;float timeSinceClick = uTime - pulseTime;if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;float pulseRadius = timeSinceClick * uPulseSpeed;float distToClick = distance(worldPos, pulsePos);float pulseThickness = 2.0;float waveProximity = abs(distToClick - pulseRadius);return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);}void main() {vNodeType = nodeType;vColor = nodeColor;vDistanceFromRoot = distanceFromRoot;vec3 worldPos = (modelMatrix * vec4(position, 1.0)).xyz;vPosition = worldPos;float totalPulseIntensity = 0.0;for (int i = 0; i < 3; i++) {totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);}vPulseIntensity = min(totalPulseIntensity, 1.0);float timeScale = 0.5 + 0.5 * sin(uTime * 0.8 + distanceFromRoot * 0.2);float baseSize = nodeSize * (0.8 + 0.2 * timeScale);float pulseSize = baseSize * (1.0 + vPulseIntensity * 2.0);vec3 modifiedPosition = position;if (nodeType > 0.5) {float noise = fbm(position * 0.1, uTime * 0.1);modifiedPosition += normal * noise * 0.2;}vec4 mvPosition = modelViewMatrix * vec4(modifiedPosition, 1.0);gl_PointSize = pulseSize * uBaseNodeSize * (800.0 / -mvPosition.z);gl_Position = projectionMatrix * mvPosition;}`, fragmentShader: `uniform float uTime;uniform vec3 uPulseColors[3];uniform int uActivePalette;varying vec3 vColor;varying float vNodeType;varying vec3 vPosition;varying float vPulseIntensity;varying float vDistanceFromRoot;void main() {vec2 center = 2.0 * gl_PointCoord - 1.0;float dist = length(center);if (dist > 1.0) discard;float glowStrength = 1.0 - smoothstep(0.0, 1.0, dist);glowStrength = pow(glowStrength, 1.4);vec3 baseColor = vColor * (0.8 + 0.2 * sin(uTime * 0.5 + vDistanceFromRoot * 0.3));vec3 finalColor = baseColor;if (vPulseIntensity > 0.0) {vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);finalColor = mix(baseColor, pulseColor, vPulseIntensity);finalColor *= (1.0 + vPulseIntensity * 0.7);}float alpha = glowStrength * (0.9 - 0.5 * dist);float camDistance = length(vPosition - cameraPosition);float distanceFade = smoothstep(80.0, 10.0, camDistance);if (vNodeType > 0.5) {alpha *= 0.85;} else {finalColor *= 1.2;}gl_FragColor = vec4(finalColor, alpha * distanceFade);}` };
        const connectionShader = { vertexShader: `${noiseFunctions}\nattribute vec3 startPoint;attribute vec3 endPoint;attribute float connectionStrength;attribute float pathIndex;attribute vec3 connectionColor;uniform float uTime;uniform vec3 uPulsePositions[3];uniform float uPulseTimes[3];uniform float uPulseSpeed;varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;float getPulseIntensity(vec3 worldPos, vec3 pulsePos, float pulseTime) {if (pulseTime < 0.0) return 0.0;float timeSinceClick = uTime - pulseTime;if (timeSinceClick < 0.0 || timeSinceClick > 3.0) return 0.0;float pulseRadius = timeSinceClick * uPulseSpeed;float distToClick = distance(worldPos, pulsePos);float pulseThickness = 2.0;float waveProximity = abs(distToClick - pulseRadius);return smoothstep(pulseThickness, 0.0, waveProximity) * smoothstep(3.0, 0.0, timeSinceClick);}void main() {float t = position.x;vPathPosition = t;vec3 midPoint = mix(startPoint, endPoint, 0.5);float pathOffset = sin(t * 3.14159) * 0.1;vec3 perpendicular = normalize(cross(normalize(endPoint - startPoint), vec3(0.0, 1.0, 0.0)));if (length(perpendicular) < 0.1) perpendicular = vec3(1.0, 0.0, 0.0);midPoint += perpendicular * pathOffset;vec3 p0 = mix(startPoint, midPoint, t);vec3 p1 = mix(midPoint, endPoint, t);vec3 finalPos = mix(p0, p1, t);float noiseTime = uTime * 0.2;float noise = fbm(vec3(pathIndex * 0.1, t * 0.5, noiseTime), noiseTime);finalPos += perpendicular * noise * 0.1;vec3 worldPos = (modelMatrix * vec4(finalPos, 1.0)).xyz;float totalPulseIntensity = 0.0;for (int i = 0; i < 3; i++) {totalPulseIntensity += getPulseIntensity(worldPos, uPulsePositions[i], uPulseTimes[i]);}vPulseIntensity = min(totalPulseIntensity, 1.0);vColor = connectionColor;vConnectionStrength = connectionStrength;gl_Position = projectionMatrix * modelViewMatrix * vec4(finalPos, 1.0);}`, fragmentShader: `uniform float uTime;uniform vec3 uPulseColors[3];varying vec3 vColor;varying float vConnectionStrength;varying float vPulseIntensity;varying float vPathPosition;void main() {vec3 baseColor = vColor * (0.7 + 0.3 * sin(uTime * 0.5 + vPathPosition * 10.0));float flowPattern = sin(vPathPosition * 20.0 - uTime * 3.0) * 0.5 + 0.5;float flowIntensity = 0.3 * flowPattern * vConnectionStrength;vec3 finalColor = baseColor;if (vPulseIntensity > 0.0) {vec3 pulseColor = mix(vec3(1.0), uPulseColors[0], 0.3);finalColor = mix(baseColor, pulseColor, vPulseIntensity);flowIntensity += vPulseIntensity * 0.5;}finalColor *= (0.6 + flowIntensity + vConnectionStrength * 0.4);float alpha = 0.8 * vConnectionStrength + 0.2 * flowPattern;alpha = mix(alpha, min(1.0, alpha * 2.0), vPulseIntensity);gl_FragColor = vec4(finalColor, alpha);}` };
        
        let neuralNetwork = null, nodesMesh = null, connectionsMesh = null;
        const clock = new THREE.Clock();

        function initApp() {
            const settingsPanel = document.getElementById('settings-panel');
            const settingsToggle = document.getElementById('settings-toggle');
            settingsToggle.addEventListener('click', () => settingsPanel.classList.toggle('open'));

            function initThreeJS() {
                createNetworkVisualization(config.currentFormation, config.densityFactor);
                updateTheme(config.activePaletteIndex);
                animate();
            }

            // --- (Event listeners for UI controls) ---
            const themeButtons = document.querySelectorAll('.theme-button');
            themeButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const idx = parseInt(btn.dataset.theme, 10);
                    updateTheme(idx);
                    themeButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });
            });
            const densitySlider = document.getElementById('density-slider');
            densitySlider.addEventListener('input', () => {
                const val = parseInt(densitySlider.value, 10);
                config.densityFactor = val / 100;
                document.getElementById('density-value').textContent = `${val}%`;
                createNetworkVisualization(config.currentFormation, config.densityFactor);
            });
            document.getElementById('change-formation-btn').addEventListener('click', () => {
                config.currentFormation = (config.currentFormation + 1) % config.numFormations;
                createNetworkVisualization(config.currentFormation, config.densityFactor);
            });
            const pausePlayBtn = document.getElementById('pause-play-btn');
            pausePlayBtn.addEventListener('click', () => {
                config.paused = !config.paused;
                pausePlayBtn.querySelector('span').textContent = config.paused ? 'Play' : 'Pause';
                controls.autoRotate = !config.paused;
            });
            document.getElementById('reset-camera-btn').addEventListener('click', () => controls.reset());
            renderer.domElement.addEventListener('click', (e) => { if (!config.paused) triggerPulse(e.clientX, e.clientY); });
            window.addEventListener('resize', onWindowResize);

            initThreeJS();
            fetchGameSaves();
        }

        function fetchGameSaves() {
            const username = 'ravisairockey';
            const repo = 'Game-save-index';
            const savesPath = 'saves';
            const container = document.getElementById('save-container');
            
            const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${savesPath}`;

            fetch(apiUrl)
                .then(response => response.json())
                .then(files => {
                    container.innerHTML = '';
                    const saveFiles = files.filter(file => file.name.endsWith('.zip'));
                    if (saveFiles.length === 0) {
                        container.innerHTML = `<div class="error-message">No .zip save files found.</div>`;
                        return;
                    }
                    saveFiles.forEach(file => {
                        const saveName = file.name.replace('.zip', '').replace(/_/g, ' ');
                        const fileSize = (file.size / 1024 / 1024).toFixed(2) + ' MB';
                        const card = document.createElement('div');
                        card.className = 'save-card';
                        card.innerHTML = `
                            <h2>${saveName}</h2>
                            <p>File: ${file.name}</p>
                            <p>Size: ${fileSize}</p>
                            <a href="${file.download_url}" class="download-button" download>Download</a>
                        `;
                        container.appendChild(card);
                    });
                })
                .catch(error => {
                    console.error('Error:', error);
                    container.innerHTML = `<div class="error-message">Failed to load save files.</div>`;
                });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApp);
        } else {
            initApp();
        }
    </script>
</body>
</html>

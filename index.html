<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Save Index</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">

    <style>
        :root {
            --hue1: 210;
            --hue2: 280;
        }
        body {
            margin: 0;
            background: #000;
        }

        .experience {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        .vignette-radial {
            position: fixed;
            z-index: 3;
            top: 0;
            left: 0;
            height: 100vh;
            width: 100%;
            pointer-events: none;
        }

        .vignette-radial:after {
            pointer-events: none;
            content: " ";
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%);
        }

        /* Main content container */
        .content-wrapper {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow-y: auto;
            z-index: 10;
            padding: 2rem;
            font-family: 'Roboto', sans-serif;
        }

        header {
            text-align: center;
            padding: 1.5rem;
            background: rgba(10, 14, 23, 0.2);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border-bottom: 1px solid hsl(var(--hue1) 80% 50% / 0.3);
        }

        header h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.5rem;
            color: #fff;
            text-shadow: 0 0 15px hsl(var(--hue1) 80% 50%);
        }

        #save-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 2rem;
            max-width: 1600px;
            margin: 2rem auto;
        }

        .save-card {
            background: linear-gradient(235deg, hsl(var(--hue1) 50% 10% / 0.7), hsl(var(--hue1) 50% 10% / 0) 45%), linear-gradient(45deg , hsl(var(--hue2) 50% 10% / 0.7), hsl(var(--hue2) 50% 10% / 0) 45%), linear-gradient(hsl(220deg 25% 4.8% / 0.5));
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid hsl(var(--hue2), 12%, 30%);
            border-radius: 22px;
            box-shadow: hsl(var(--hue2) 50% 2%) 0px 10px 16px -8px, hsl(var(--hue2) 50% 4%) 0px 20px 36px -14px;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            position: relative;
            overflow: hidden;
            color: #f0f8ff;
        }
        
        .save-card:hover {
            transform: translateY(-5px);
            box-shadow: hsl(var(--hue1) 80% 50% / 0.3) 0px 10px 30px -10px;
        }

        .save-card h2 {
            font-family: 'Orbitron', sans-serif;
            color: #fff;
            font-size: 1.4rem;
        }

        .save-card p {
            color: #b0c4de;
            font-size: 0.9rem;
        }
        
        .download-button {
            margin-top: auto;
            padding: 0.8rem 1.2rem;
            background: hsl(var(--hue1) 30% 15% / 0.5);
            border: 1px solid hsl(var(--hue1) 15% 16% / 0.5);
            color: #fff;
            text-decoration: none;
            text-align: center;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .download-button:hover {
            background: hsl(var(--hue1) 40% 24% / 0.8);
            box-shadow: 0 0 15px hsl(var(--hue1) 80% 50% / 0.5);
        }

        .loader, .error-message {
            grid-column: 1 / -1;
            text-align: center;
            padding: 3rem;
            font-size: 1.2rem;
            color: #b0c4de;
            background: rgba(10, 14, 23, 0.5);
            backdrop-filter: blur(5px);
            border-radius: 22px;
        }
    </style>
</head>
<body>
    <canvas class="experience"></canvas>
    <div class="vignette-radial"></div>

    <div class="content-wrapper">
        <header>
            <h1>Game Save Index</h1>
        </header>
        <main>
            <div id="save-container">
                <div class="loader">Loading Save Files...</div>
            </div>
        </main>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.162.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.162.0/examples/jsm/"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let w = window.innerWidth;
        let h = window.innerHeight;

        const renderer = new THREE.WebGLRenderer({
            canvas: document.querySelector("canvas.experience"),
            antialias: true
        });
        renderer.setSize(w, h);

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
        camera.position.z = 5;

        const generatePathPoints = (count = 20, spacing = 50) => {
            const points = [];
            for (let i = 0; i < count; i++) {
                const x = i * spacing - ((count * spacing) / 2);
                const y = Math.sin(i * 0.5 + Math.random()) * 20;
                const z = Math.cos(i * 0.3 + Math.random()) * 20;
                points.push(new THREE.Vector3(x, y, z));
            }
            return points;
        };

        const points = generatePathPoints();
        const path = new THREE.CatmullRomCurve3(points);
        path.closed = true;
        path.tension = 0.5;

        const ringCount = 400;
        const ringRadius = 1.5;
        const ringSegments = 24;

        const geometry = new THREE.TubeGeometry(path, ringCount, ringRadius, ringSegments, true);
        
        const frenetFrames = path.computeFrenetFrames(ringCount, true);

        const ringMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, depthWrite: false });

        for (let i = 0; i <= ringCount; i++) {
            if (i % 4 !== 0) continue; // Create fewer rings for performance
            const t = i / ringCount;
            const pos = path.getPointAt(t);
            const normal = frenetFrames.normals[i];
            const binormal = frenetFrames.binormals[i];

            const ringPoints = [];
            for (let j = 0; j <= ringSegments; j++) {
                const theta = (j / ringSegments) * Math.PI * 2;
                const x = Math.cos(theta) * ringRadius;
                const y = Math.sin(theta) * ringRadius;
                const point = new THREE.Vector3().addVectors(pos, new THREE.Vector3().addScaledVector(normal, x).addScaledVector(binormal, y));
                ringPoints.push(point);
            }
            const ringGeometry = new THREE.BufferGeometry().setFromPoints(ringPoints);
            const ringMesh = new THREE.LineLoop(ringGeometry, ringMaterial);
            scene.add(ringMesh);
        }

        const light = new THREE.PointLight(0xffffff, 1, 100, 2);
        scene.add(light);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(w, h), 0.8, 0.4, 0.5);
        
        const composer = new THREE.EffectComposer(renderer);
        composer.setSize(w, h);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const clock = new THREE.Clock();
        
        function updateCamera() {
            const t = (clock.getElapsedTime() * 0.01) % 1;
            const pos = path.getPointAt(t);
            const lookAtPos = path.getPointAt((t + 0.01) % 1);
            
            camera.position.lerp(pos, 0.02);
            camera.lookAt(lookAtPos);
            light.position.copy(lookAtPos);
        }

        function render() {
            updateCamera();
            composer.render();
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        window.addEventListener("resize", () => {
            w = window.innerWidth;
            h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
            composer.setSize(w, h);
        });

        // Game Save Fetching Logic
        function fetchGameSaves() {
            const username = 'ravisairockey';
            const repo = 'Game-save-index';
            const savesPath = 'saves';
            const container = document.getElementById('save-container');
            
            const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${savesPath}`;

            fetch(apiUrl)
                .then(response => {
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    return response.json();
                })
                .then(files => {
                    container.innerHTML = ''; // Clear loader
                    
                    const saveFiles = files.filter(file => file.type === 'file' && file.name.endsWith('.zip'));
                    
                    if (saveFiles.length === 0) {
                        let message = "No .zip save files found. Upload your game saves in ZIP format.";
                        if (files.message && files.message.includes("Not Found")) {
                            message = "Could not find the 'saves' directory. Please create it and add your save files.";
                        }
                        container.innerHTML = `<div class="error-message">${message}</div>`;
                        return;
                    }

                    saveFiles.forEach((file, index) => {
                        const saveName = file.name.replace('.zip', '').replace(/_/g, ' ');
                        const downloadUrl = file.download_url;
                        const fileSize = file.size ? (file.size / 1024 / 1024).toFixed(2) + ' MB' : 'Size unknown';

                        const card = document.createElement('div');
                        card.className = 'save-card';
                        
                        card.innerHTML = `
                            <h2>${saveName}</h2>
                            <p>File: ${file.name}</p>
                            <p>Size: ${fileSize}</p>
                            <a href="${downloadUrl}" class="download-button" download>Download</a>
                        `;
                        container.appendChild(card);
                    });
                })
                .catch(error => {
                    console.error('Error fetching save files:', error);
                    container.innerHTML = `<div class="error-message">Could not load save files. Check your internet connection or the browser console for details.</div>`;
                });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', fetchGameSaves);
        } else {
            fetchGameSaves();
        }
    </script>
</body>
</html>
